//
//  BotMessage.swift
//  
//
//  Created by Vincent Kwok on 22/11/22.
//

import Foundation
import DiscordKitCore

/// A Discord message, with convenience methods.
public struct BotMessage {
    /// ID of the message
    public let id: Snowflake

    /// Channel the message was sent in
    //public let channel: Channel

    /// ID of the channel the message was sent in
    public let channelID: Snowflake

    /// The guild the message was sent in
    public let guild: BotGuild?
    /// ID of the guild the message was sent in
    public let guildID: Snowflake?

    /// The author of this message (not guaranteed to be a valid user, see discussion)
    ///
    /// Will not be a valid user if the message was sent by a webhook.
    /// > The author object follows the structure of the user object,
    /// > but is only a valid user in the case where the message is generated
    /// > by a user or bot user. If the message is generated by a webhook, the
    /// > author object corresponds to the webhook's id, username, and avatar.
    /// > You can tell if a message is generated by a webhook by checking for
    /// > the webhook_id on the message object.
    public var author: User

    /// Member properties for this message's author
    public var member: BotMember?

    /// Contents of the message
    ///
    /// Up to 2000 characters for non-premium users.
    public var content: String

    /// When this message was sent
    public let timestamp: Date

    /// When this message was edited (or null if never)
    public var editedTimestamp: Date?

    /// If this was a TTS message
    public var tts: Bool

    /// Whether this message mentions everyone
    public var mentionEveryone: Bool

    /// Users specifically mentioned in the message
    public var mentions: [User]

    /// Roles specifically mentioned in this message
    public var mentionRoles: [Snowflake]

    /// Channels specifically mentioned in this message
    public var mentionChannels: [ChannelMention]?

    /// Any attached files
    ///
    /// See ``Attachment`` for more details.
    public var attachments: [Attachment]

    /// Any embedded content
    ///
    /// See ``Embed`` for more details
    public var embeds: [Embed]

    /// Reactions to the message
    public var reactions: [Reaction]?
    // Nonce can either be string or int and isn't important so I'm not including it for now

    /// If this message is pinned
    public var pinned: Bool

    /// If the message is generated by a webhook, this is the webhook's ID
    ///
    /// Use this to check if the message is sent by a webhook. ``Message/author``
    /// will not be valid if this is not nil (was sent by a webhook).
    public var webhookID: Snowflake?

    /// Type of message
    ///
    /// Refer to ``MessageType`` for possible values.
    public let type: MessageType

    /// Sent with Rich Presence-related chat embeds
    public var activity: MessageActivity?

    /// Sent with Rich Presence-related chat embeds
    public var application: Application?

    /// If the message is an Interaction or application-owned webhook, this is the ID of the application
    public var application_id: Snowflake?

    /// Data showing the source of a crosspost, channel follow add, pin, or reply message
    public var messageReference: MessageReference?

    /// Message flags
    public var flags: Int?

    /// The message associated with the message\_reference
    ///
    /// This field is only returned for messages with a type of ``MessageType/reply``
    /// or ``MessageType/threadStarterMsg``. If the message is a reply but the
    /// referenced\_message field is not present, the backend did not attempt to
    /// fetch the message that was being replied to, so its state is unknown. If
    /// the field exists but is null, the referenced message was deleted.
    ///
    /// > Currently, it is not possible to distinguish between the field being `nil`
    /// > or the field not being present. This is due to limitations with the built-in
    /// > `Decodable` type.
    public let referencedMessage: Message?

    /// Present if the message is a response to an Interaction
    public var interaction: MessageInteraction?

    /// The thread that was started from this message, includes thread member object
    public var thread: Channel?

    /// Present if the message contains components like buttons, action rows, or other interactive components
    public var components: [MessageComponent]?

    /// Present if the message contains stickers
    public var stickers: [StickerItem]?

    /// Present if the message is a call in DM
    public var call: CallMessageComponent?

    /// The url to jump to this message
    public var jumpURL: URL?

    // The REST handler associated with this message, used for message actions
    fileprivate weak var rest: DiscordREST?

    internal init(from message: Message, rest: DiscordREST) async {
        content = message.content
        channelID = message.channel_id
        id = message.id
        guildID = message.guild_id
        author = message.author
        if let messageMember = message.member {
            member = BotMember(from: messageMember, rest: rest)
        }
        timestamp = message.timestamp
        editedTimestamp = message.edited_timestamp
        tts = message.tts
        mentionEveryone = message.mention_everyone
        mentions = message.mentions
        mentionRoles = message.mention_roles
        mentionChannels = message.mention_channels
        attachments = message.attachments
        embeds = message.embeds
        reactions = message.reactions
        pinned = message.pinned
        webhookID = message.webhook_id
        type = message.type
        activity = message.activity
        application = message.application
        application_id = message.application_id
        messageReference = message.message_reference
        flags = message.flags
        referencedMessage = message.referenced_message
        interaction = message.interaction
        thread = message.thread
        components = message.components
        stickers = message.sticker_items
        call = message.call

        self.rest = rest

        guild = try? await Client.current?.getGuild(id: guildID ?? "")

        //jumpURL = nil
    }
}

public extension BotMessage {
    func reply(_ content: String) async throws -> Message {
        return try await rest!.createChannelMsg(
            message: .init(content: content, message_reference: .init(message_id: id), components: []),
            id: channelID
        )
    }

    func delete() async throws {
        try await rest!.deleteMsg(id: channelID, msgID: id)
    }

    func addReaction(emoji: Snowflake) async throws {
        try await rest!.createReaction(channelID, id, emoji)
    }

    func removeReaction(emoji: Snowflake) async throws {
        try await rest!.deleteOwnReaction(channelID, id, emoji)
    }

    func clearAllReactions() async throws {
        try await rest!.deleteAllReactions(channelID, id)
    }

    func clearAllReactions(for emoji: Snowflake) async throws {
        try await rest!.deleteAllReactionsforEmoji(channelID, id, emoji)
    }

    func createThread(name: String, autoArchiveDuration: Int?, rateLimitPerUser: Int?) async throws -> Channel {
        let body = CreateThreadRequest(name: name, auto_archive_duration: autoArchiveDuration, rate_limit_per_user: rateLimitPerUser)
        return try await rest!.startThreadfromMessage(channelID, id, body)
    }
}
